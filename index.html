<!DOCTYPE html>

<style>

.selecting path {
  fill-opacity: .2;
}

.selecting path.selected {
  stroke: red;
  stroke-width: 2px;
}

.axis path,
.axis line {
    fill: none;
    stroke: #eee;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}

.loading {
    font-family: sans-serif;
    font-size: 15px;
}

.circle {
    fill: #222;
}

</style>


<div id="graph"></div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script >


//notes:
// lets start with a line, if it looks too choppy, use a curve instead
var newData = [];

d3.json("data.json", function(data){

  var person1 = [];
  var numberOfPeople = 200;
  for(i = 0; i < data.length; i++){
    if(data[i].person <= numberOfPeople-1 ){
      person1.push(data[i]);
    }
  }


  var xMin = d3.min(data, function(d){return d.x}), //max and min
      xMax = d3.max(data, function(d){return d.x}),
      yMin = d3.min(data, function(d){return d.y}),
      yMax = d3.max(data, function(d){return d.y});


  var w = 1080,
      h = 600,
      pad = 20,
      left_pad = 100;

  var svg = d3.select("#graph")
              .append("svg")
              .attr("width", w)
              .attr("height", h);


  var xScale = d3.scaleLinear().domain([xMin,xMax]).range([left_pad, w-pad]),
      yScale = d3.scaleLinear().domain([yMax,yMin]).range([pad, h-pad*2]);

  var xAxis = d3.axisBottom(xScale),
      yAxis = d3.axisLeft(yScale);

  var cValue = function(d) { return d.person;},
      color = d3.scaleOrdinal(d3.schemeCategory10);

  var line = d3.line()
    .x(function(d){return xScale(d.x);})
    .y(function(d){return yScale(d.y);});


  svg.append("g")
     .attr("class", "axis")
     .attr("transform", "translate(0, "+(h-pad)+")")
     .call(xAxis);

  svg.append("g")
     .attr("class", "axis")
     .attr("transform", "translate("+(left_pad-pad)+", 0)")
     .call(yAxis);

  svg.append("g")
      .attr("class", "brush")
      .call(d3.brushY()
      .on("start", brushstart)
      .on("brush",brushed));

  for(i = 0; i < numberOfPeople; i++){
    var tempperson = [];
    for(j = 0; j < person1.length; j++){
      if(person1[j].person == i){
        tempperson.push(person1[j]);
      }
    }
    // console.log(person);
    svg.append("path")
      .datum(tempperson)
      .attr("class", "line")
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-width", 1.5)
      .attr("d", line);
  }



  var dd = data.slice(0,100);
  console.log(data.length);



  // svg.selectAll("circle")
  //    .data(person1)
  //    .enter()
  //    .append("circle")
  //    .attr("class", "circle")
  //    .attr("cx", function (d) { return xScale(d.x) })
  //    .attr("cy", function (d) { return yScale(d.y) })
  //    .attr("r", 2)
  //    .style("fill",function(d) { return color(d.person);} );


     //Det hÃ¤r fungerar ju inte
    function brushstart() {
     svg.classed("selecting", true);
    }

     //the function that takes care of what happens on "brush" event
   function brushed() {
     var area = d3.event.selection;
     var miny = area[0];
     var maxy = area[1];
     svg.selectAll("circle").style("fill-opacity",function(d){
       // console.log("miny: " + miny + " maxy: " + maxy);
       if(yScale(d.y) >= miny && yScale(d.y) <= maxy){
         return "1";
       }else{
         return "0.2";
       }
     });

     var s = d3.event.target.extent();  //nope
     var symbol = svg.selectAll("line");
     symbol.classed("selected", function(d) { return s[0] <= (d = xScale(d)) && d <= s[1]; });  //funkar inte just nu

   }//brushed
});



</script>
